最近在读设计模式， 感觉早就应该来看了。。

一个简单的 闭包声明构造函数

```
var Book = (function(){
//私有变量
var count = 0;
function checkBook (){console.log('static method')}
function _book (name, price){
var name, price;
count++

this.setName = function(n){this.name = name}

if(count > 2){
  alert('我们仅发售2本书'); 
  throw new Error('我们仅发售2本书'); 
 }
this.setName(name)

}
_book.prototype = {
    isJSBook: false,
    display: function(){}
}
return _book
})()
```
不会造成全局变量污染， 内部的count变量，记录new了多少个实例了，超过以后就抛出一个错误。
var b1 = new Book('权威指南1', 1.11)
b1.name ==>   "权威指南1"

var bb3 = new Book('权威指南', 1.11)
当new到3的时候  就会报出错误  使new的对象不成功
VM8715:10 Uncaught Error: 我们仅发售2本书(…)




## 原型链 特别难搞的一个东东
子类的 和 子类的实例的__proto__ 指向子类的原型 prototype

对子类原型的处理： 被赋予父类原型的一个引用（不是原型本身），这是一个对象，子类再想添加原型方法，必须通过prototype.对象,一个一个添加，否则直接赋予对象就会覆盖掉从父类原型继承的对象了。

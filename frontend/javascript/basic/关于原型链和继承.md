## 原型链和继承

js本身在ES6前是没有专门的继承语法， 也没有专门的机制。  我们在用的时候，都是靠原型来实现
原型： 是一个不对外公开的， 在chrome中 是会暴露一个标志 __proto__ 来访问我们的原型。
注意： prototype 和 原型 是不同的 有区别的。
+ prototype 是只存在函数之间的， 用来指向该函数原型的标志符。
+ 原型 是一个对象的类型， 可以用instansof来判断， 一个对象 是否是另一个 函数或构造器的实例或者子类。
+ instansof 左边必须是对象(不能是普通的基本类型)， 而右边 必须是一个函数 或者函数构造器  否则会报错

原型 其实是一个普通对象 名字与他的构造器相同。 只是不公开对外暴露。


```
function Person (name) {
  this.name = name
}

Person.prototype.say = function () {
  console.log(this.name , '在说话')
}

function Student (name, clazz) {
// 这里调用父类的构造方法，将name初始化（虽然name不应该让父亲初始化。。。）
  Person.call(this, name)
  this.clazz = clazz
}

Student.prototype = Object.create(Person.prototype)
Student.prototype.constructor = Student
```
> 这样下来， student就继承了Person 成功的将原型指向了Person的prototype属性。

```
p instanceof Person
true
s instanceof Person
true
s2 instanceof Person
true
Student instanceof Person
false
Student instanceof Object
true
```
Student 不是 Person 的实例所以 Student instanceof Person 是false
